# -*- coding: utf-8 -*-
"""Untitled9.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14ef0fU0K3nbmX8nx88-3nXu8PyjwN4_s
"""

import streamlit as st
import zipfile
import io
import random
import requests
import unicodedata
import re

# âœ… Dropboxãƒªãƒ³ã‚¯ï¼ˆå›ºå®šï¼‰
DROPBOX_URL = "https://www.dropbox.com/scl/fi/i50xzf0isskjrle7yrcof/mp3-10.zip?rlkey=7ke725jn53j7qb0k6cfiptvtx&st=4uv4cp2y&raw=1"

# ğŸ¯ ã‚»ãƒƒã‚·ãƒ§ãƒ³åˆæœŸåŒ–
def init_session():
    defaults = {
        "questions": [],
        "current_q": 0,
        "score": 0,
        "zip_data": None,
        "played": False,
        "answered": False,
    }
    for key, val in defaults.items():
        if key not in st.session_state:
            st.session_state[key] = val

init_session()

# ğŸµ ãƒ’ãƒ³ãƒˆç”Ÿæˆï¼ˆæœ€åˆã®1æ–‡å­—ï¼‹ã€‡ï¼‹æ–‡å­—æ•°è¡¨ç¤ºï¼‰
def generate_hint(answer: str) -> str:
    if not answer:
        return ""
    first = answer[0]
    masked = ""
    for char in answer[1:]:
        if char.isalpha() or ('ã' <= char <= 'ã‚“') or ('ã‚¡' <= char <= 'ãƒ³') or ('ä¸€' <= char <= 'é¾¥'):
            masked += "ã€‡"
        elif char == " ":
            masked += "â–¡"
        else:
            masked += char
    return f"{first}{masked}ï¼ˆå…¨{len(answer)}æ–‡å­—ï¼‰"

# ğŸ”¤ æ­£è¦åŒ–ï¼ˆå…¨è§’â†’åŠè§’ã€å°æ–‡å­—åŒ–ã€ç©ºç™½é™¤å»ï¼‰
def normalize(text: str) -> str:
    return unicodedata.normalize("NFKC", text).lower().replace(" ", "").replace("ã€€", "")

# ğŸ“ ãƒ•ã‚¡ã‚¤ãƒ«åã‹ã‚‰ç­”ãˆã‚’æŠ½å‡º
def extract_answer(filename: str) -> str:
    name = filename.rsplit("/", 1)[-1].rsplit(".", 1)[0]
    parts = name.split("_", 1)
    return parts[1] if len(parts) == 2 else parts[0]

# ğŸŒŸ é›£æ˜“åº¦æŠ½å‡ºï¼ˆâ˜†ãªã—â†’â˜†2æ‰±ã„ï¼‰
def extract_difficulty(filename: str) -> str:
    match = re.search(r'[ ã€€]*â˜†[1-5]', filename)
    return match.group().strip() if match else "â˜†2"

# ğŸ“ èª¬æ˜æ¬„
st.title("ğŸ® ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆæ¤œå®š æ¥½æ›²ç·¨")
st.markdown(f"""
#### ğŸ“ èª¬æ˜
- æ›²ã®ä¸€éƒ¨ãŒæµã‚Œã¾ã™ã€‚
- **ã²ã‚‰ãŒãªã€ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã®å°æ–‡å­—**ã§å›ç­”ã—ã¦ãã ã•ã„ã€‚
- **ã‚¹ãƒšãƒ¼ã‚¹ï¼ˆâ–¡ï¼‰ã€ãƒ‰ãƒƒãƒˆã€è¨˜å·**ã¯ãƒ’ãƒ³ãƒˆã¨ã—ã¦è¡¨ç¤ºã•ã‚Œã¾ã™ã€‚ãƒ’ãƒ³ãƒˆã‚‚å…¥åŠ›ã—ã¦ãã ã•ã„ã€‚
- 200å•ä»¥ä¸Šã®ä¸­ã‹ã‚‰**50å•ã¾ã§ãƒ©ãƒ³ãƒ€ãƒ å‡ºé¡Œ**ã•ã‚Œã¾ã™ã€‚
- å•é¡Œã¯**ä¸€åº¦ã—ã‹æµã‚Œã¾ã›ã‚“**ã€‚
- å‡ºé¡ŒåŸºæº–ã¯ã€Œ**ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒƒãƒˆã‚’è¦‹ã¦ã„ã‚Œã°å›ç­”ã§ãã‚‹**ã€ã§ã™ã€‚
- éŸ³é‡ãŒä¸€å®šã§ãªã„ã®ã§ã€**éŸ³é‡ã®ä¸Šã’ã™ãã«ã¯ã”æ³¨æ„ãã ã•ã„**ã€‚
- ğŸ”— [éŸ³å£°ZIPã¯ã“ã¡ã‚‰]({DROPBOX_URL})
""")

# ğŸ“¦ ZIPèª­ã¿è¾¼ã¿ï¼†å•é¡ŒæŠ½å‡ºï¼ˆåˆå›ã®ã¿ï¼‰
if DROPBOX_URL and not st.session_state.questions:
    with st.spinner("ZIPãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ä¸­..."):
        response = requests.get(DROPBOX_URL)
        st.session_state.zip_data = io.BytesIO(response.content)

        with zipfile.ZipFile(st.session_state.zip_data) as z:
            all_mp3 = [f for f in z.namelist() if f.endswith(".mp3")]

            selected_questions = []
            used_files = set()
            while len(selected_questions) < 50 and all_mp3:
                f = random.choice(all_mp3)
                if f not in used_files:
                    ans = extract_answer(f).strip()
                    selected_questions.append({"file": f, "answer": ans})
                    used_files.add(f)

            st.session_state.questions = selected_questions

# ğŸš€ ã‚¯ã‚¤ã‚ºé€²è¡Œ
if st.session_state.questions:
    idx = st.session_state.current_q

    if idx >= len(st.session_state.questions):
        st.markdown("---")
        st.header("ğŸ ã‚¯ã‚¤ã‚ºçµ‚äº†ï¼")
        st.write(f"ã‚ãªãŸã®ã‚¹ã‚³ã‚¢ï¼š**{st.session_state.score} / {len(st.session_state.questions)}**")
        st.balloons()
        if st.button("ã‚‚ã†ä¸€åº¦æŒ‘æˆ¦ã™ã‚‹"):
            for key in ["questions", "current_q", "score", "zip_data", "played", "answered"]:
                st.session_state[key] = {
                    "questions": [],
                    "current_q": 0,
                    "score": 0,
                    "zip_data": None,
                    "played": False,
                    "answered": False,
                }[key]
            st.experimental_rerun()
        st.stop()

    q = st.session_state.questions[idx]
    difficulty = extract_difficulty(q["file"])

    with zipfile.ZipFile(st.session_state.zip_data) as z:
        if not st.session_state.played:
            st.audio(z.read(q["file"]), format="audio/mp3")
            st.session_state.played = True
        else:
            st.info("éŸ³å£°ã¯1å›ã®ã¿å†ç”Ÿã•ã‚Œã¾ã™ã€‚å†èª­ã¿è¾¼ã¿ã§ãƒªã‚»ãƒƒãƒˆã§ãã¾ã™ã€‚")

    st.subheader(f"ğŸµ ç¬¬ {idx + 1} å•ï¼ˆé›£æ˜“åº¦ï¼š{difficulty}ï¼‰")
    st.write("ğŸ” ãƒ’ãƒ³ãƒˆï¼š" + generate_hint(q["answer"]))

    user_input = st.text_input("ç­”ãˆã‚’å…¥åŠ›ï¼ˆã²ã‚‰ãŒãªãƒ»è‹±å°æ–‡å­—ï¼‰", key=f"answer_{idx}")

    if not st.session_state.answered and st.button("å›ç­”ã™ã‚‹"):
        st.session_state.answered = True
        if normalize(user_input) == normalize(q["answer"]):
            st.success("ğŸ‰ æ­£è§£ï¼")
            st.session_state.score += 1
        else:
            st.error(f"âŒ ä¸æ­£è§£â€¦ æ­£è§£ã¯ã€Œ{q['answer']}ã€ã§ã—ãŸ")

    if st.session_state.answered:
        if st.button("æ¬¡ã®å•é¡Œã¸"):
            st.session_state.current_q += 1
            st.session_state.played = False
            st.session_state.answered = False
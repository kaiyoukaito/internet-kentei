# -*- coding: utf-8 -*-
"""Untitled9.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14ef0fU0K3nbmX8nx88-3nXu8PyjwN4_s
"""

import streamlit as st
import zipfile
import io
import random
import requests
import unicodedata
import re

# ✅ Dropboxリンク（固定）
DROPBOX_URL = "https://www.dropbox.com/scl/fi/i50xzf0isskjrle7yrcof/mp3-10.zip?rlkey=7ke725jn53j7qb0k6cfiptvtx&st=4uv4cp2y&raw=1"

# 🎯 セッション初期化
def init_session():
    defaults = {
        "questions": [],
        "current_q": 0,
        "score": 0,
        "zip_data": None,
        "played": False,
        "answered": False,
    }
    for key, val in defaults.items():
        if key not in st.session_state:
            st.session_state[key] = val

init_session()

# 🎵 ヒント生成（最初の1文字＋〇＋文字数表示）
def generate_hint(answer: str) -> str:
    if not answer:
        return ""
    first = answer[0]
    masked = ""
    for char in answer[1:]:
        if char.isalpha() or ('ぁ' <= char <= 'ん') or ('ァ' <= char <= 'ン') or ('一' <= char <= '龥'):
            masked += "〇"
        elif char == " ":
            masked += "□"
        else:
            masked += char
    return f"{first}{masked}（全{len(answer)}文字）"

# 🔤 正規化（全角→半角、小文字化、空白除去）
def normalize(text: str) -> str:
    return unicodedata.normalize("NFKC", text).lower().replace(" ", "").replace("　", "")

# 📁 ファイル名から答えを抽出
def extract_answer(filename: str) -> str:
    name = filename.rsplit("/", 1)[-1].rsplit(".", 1)[0]
    parts = name.split("_", 1)
    return parts[1] if len(parts) == 2 else parts[0]

# 🌟 難易度抽出（☆なし→☆2扱い）
def extract_difficulty(filename: str) -> str:
    match = re.search(r'[ 　]*☆[1-5]', filename)
    return match.group().strip() if match else "☆2"

# 📝 説明欄
st.title("🎮 インターネット検定 楽曲編")
st.markdown(f"""
#### 📝 説明
- 曲の一部が流れます。
- **ひらがな、アルファベットの小文字**で回答してください。
- **スペース（□）、ドット、記号**はヒントとして表示されます。ヒントも入力してください。
- 200問以上の中から**50問までランダム出題**されます。
- 問題は**一度しか流れません**。
- 出題基準は「**インターネットを見ていれば回答できる**」です。
- 音量が一定でないので、**音量の上げすぎにはご注意ください**。
- 🔗 [音声ZIPはこちら]({DROPBOX_URL})
""")

# 📦 ZIP読み込み＆問題抽出（初回のみ）
if DROPBOX_URL and not st.session_state.questions:
    with st.spinner("ZIPファイルをダウンロード中..."):
        response = requests.get(DROPBOX_URL)
        st.session_state.zip_data = io.BytesIO(response.content)

        with zipfile.ZipFile(st.session_state.zip_data) as z:
            all_mp3 = [f for f in z.namelist() if f.endswith(".mp3")]

            selected_questions = []
            used_files = set()
            while len(selected_questions) < 50 and all_mp3:
                f = random.choice(all_mp3)
                if f not in used_files:
                    ans = extract_answer(f).strip()
                    selected_questions.append({"file": f, "answer": ans})
                    used_files.add(f)

            st.session_state.questions = selected_questions

# 🚀 クイズ進行
if st.session_state.questions:
    idx = st.session_state.current_q

    if idx >= len(st.session_state.questions):
        st.markdown("---")
        st.header("🏁 クイズ終了！")
        st.write(f"あなたのスコア：**{st.session_state.score} / {len(st.session_state.questions)}**")
        st.balloons()
        if st.button("もう一度挑戦する"):
            for key in ["questions", "current_q", "score", "zip_data", "played", "answered"]:
                st.session_state[key] = {
                    "questions": [],
                    "current_q": 0,
                    "score": 0,
                    "zip_data": None,
                    "played": False,
                    "answered": False,
                }[key]
            st.experimental_rerun()
        st.stop()

    q = st.session_state.questions[idx]
    difficulty = extract_difficulty(q["file"])

    with zipfile.ZipFile(st.session_state.zip_data) as z:
        if not st.session_state.played:
            st.audio(z.read(q["file"]), format="audio/mp3")
            st.session_state.played = True
        else:
            st.info("音声は1回のみ再生されます。再読み込みでリセットできます。")

    st.subheader(f"🎵 第 {idx + 1} 問（難易度：{difficulty}）")
    st.write("🔍 ヒント：" + generate_hint(q["answer"]))

    user_input = st.text_input("答えを入力（ひらがな・英小文字）", key=f"answer_{idx}")

    if not st.session_state.answered and st.button("回答する"):
        st.session_state.answered = True
        if normalize(user_input) == normalize(q["answer"]):
            st.success("🎉 正解！")
            st.session_state.score += 1
        else:
            st.error(f"❌ 不正解… 正解は「{q['answer']}」でした")

    if st.session_state.answered:
        if st.button("次の問題へ"):
            st.session_state.current_q += 1
            st.session_state.played = False
            st.session_state.answered = False